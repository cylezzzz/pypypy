<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Katalog / Store – AndioMediaStudio</title>
  <link rel="icon" type="image/png" href="assets/logo/logo.png"/>
  <link rel="stylesheet" href="assets/styles.css"/>
  <style>
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:8px}
    .toolbar input[type="search"]{min-width:220px}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:12px}
    .thumb{width:100%;aspect-ratio:16/9;object-fit:cover;border-radius:8px;background:#222;border:1px solid #222}
    .row{display:flex;gap:8px;align-items:center;margin:6px 0}
    .badge{font-size:.8em;background:#222;color:#ccc;border:1px solid #333;border-radius:999px;padding:2px 8px}
    .muted{color:#888}
    .pill{font-size:.8em;border-radius:999px;padding:2px 8px;border:1px solid #333}
    .right{margin-left:auto}
  </style>
</head>
<body>
  <script src="assets/app.js"></script>
  <script>window.Andio && Andio.navbar && Andio.navbar('catalog');</script>

  <div class="container">
    <h1>Katalog / Store</h1>
    <p class="muted">API-first (<code>/api/catalog</code>), sonst statische Fallbacks. Install/Entfernen nutzt API; wenn nicht vorhanden, wird lokal markiert.</p>

    <div class="card toolbar">
      <button id="btn-refresh">Aktualisieren</button>
      <select id="filter-family" title="Familie">
        <option value="">Familie: Alle</option>
        <option value="sd15">SD 1.5</option>
        <option value="sdxl">SDXL</option>
        <option value="svd">SVD (Video)</option>
        <option value="flux">FLUX</option>
        <option value="lora">LoRA</option>
      </select>
      <select id="filter-state" title="Status">
        <option value="">Status: Alle</option>
        <option value="installed">Installiert</option>
        <option value="available">Verfügbar</option>
      </select>
      <input id="search" type="search" placeholder="Suche nach Name/ID/Tag …"/>
      <span class="right muted" id="count"></span>
    </div>

    <div id="list" class="grid"></div>
  </div>

  <footer>© AndioMediaStudio</footer>

  <script>
  const FALLBACK_COVER = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=";

  function dedupeById(list){
    const m=new Map();
    for(const x of (list||[])){ const k=(x.id||x.name||'').toLowerCase(); if(!k) continue; if(!m.has(k)) m.set(k,x); }
    return [...m.values()];
  }
  async function getJSON(url){
    try{ const r=await fetch(url,{cache:'no-cache'}); if(r.ok) return await r.json(); }catch(_){}
    return null;
  }

  async function loadFromApi(){
    const d = await getJSON('/api/catalog');
    if(!d) return null;
    let items = [];
    if (Array.isArray(d)) items = d;
    if (Array.isArray(d.models)) items = d.models;
    const a = (d.available||[]);
    const i = (d.installed||[]);
    if (a.length || i.length){
      const mark = (arr,flag)=>arr.map(x=>Object.assign({},x,{_api:true,installed: !!flag}));
      items = dedupeById([ ...mark(i,true), ...mark(a,false) ]);
    }
    return items;
  }

  async function loadFromStatic(){
    const a = await getJSON('assets/catalog.json');
    const b = await getJSON('assets/catalog/community.json');
    const c = await getJSON('assets/catalog/andio-official.json');
    let items = [];
    if (a){ 
      if (Array.isArray(a.models)) items.push(...a.models);
      if (Array.isArray(a.featured)) items.push(...a.featured);
    }
    if (Array.isArray(b)) items.push(...b);
    if (Array.isArray(c)) items.push(...c);
    items = dedupeById(items);
    items = items.map(x=>Object.assign({},x,{installed: !!x.is_installed}));
    return items;
  }

  function markInstalledByLocal(items){
    return items.map(x=>{
      const id = x.id || x.name;
      const local = localStorage.getItem('model:installed:'+id);
      return Object.assign({}, x, { installed: local ? local === '1' : !!x.installed });
    });
  }
  function saveInstalledLocal(id, installed){
    try{ localStorage.setItem('model:installed:'+id, installed ? '1' : '0'); }catch(_){}
  }

  function familyBadge(f){
    if(!f) return '';
    const up = String(f).toUpperCase();
    return `<span class="badge">${up}</span>`;
  }
  function tagsRow(tags){
    return (tags||[]).slice(0,6).map(t=>`<span class="pill">${t}</span>`).join(' ');
  }

  function matchFilters(x, q, fam, state){
    if (fam && String(x.family||'').toLowerCase() !== fam) return false;
    if (state==='installed' && !x.installed) return false;
    if (state==='available' && x.installed) return false;
    if (q){
      const s = (x.id+' '+(x.name||'')+' '+(x.tags||[]).join(' ')).toLowerCase();
      if (!s.includes(q.toLowerCase())) return false;
    }
    return true;
  }

  function render(items){
    const list = document.getElementById('list');
    const q = document.getElementById('search').value.trim();
    const fam = document.getElementById('filter-family').value;
    const state = document.getElementById('filter-state').value;
    list.innerHTML='';
    const shown = items.filter(x=>matchFilters(x,q,fam,state));
    document.getElementById('count').textContent = `${shown.length} / ${items.length}`;

    for(const m of shown){
      const card = document.createElement('div');
      card.className='card';

      const img = document.createElement('img');
      img.className='thumb';
      const cover = m.cover || m.img || m.example || 'assets/placeholders/model-cover.png';
      img.src = cover;
      img.alt = m.name || m.id || 'Model-Cover';
      img.onerror = ()=>{ img.src = FALLBACK_COVER; };
      card.appendChild(img);

      const h3 = document.createElement('h3');
      h3.textContent = m.name || m.id;
      card.appendChild(h3);

      const meta = document.createElement('div');
      meta.className='row';
      meta.innerHTML = `${familyBadge(m.family)} <span class="muted">${m.id||''}</span>`;
      card.appendChild(meta);

      const tg = document.createElement('div');
      tg.className='row';
      tg.innerHTML = tagsRow(m.tags);
      card.appendChild(tg);

      const actions = document.createElement('div');
      actions.className='row';

      const useBtn = document.createElement('button');
      useBtn.textContent='ID kopieren';
      useBtn.addEventListener('click', async ()=>{
        try{ await navigator.clipboard.writeText(m.id||m.name||''); useBtn.textContent='Kopiert ✓'; setTimeout(()=>useBtn.textContent='ID kopieren',1200);}catch(_){}
      });
      actions.appendChild(useBtn);

      const instBtn = document.createElement('button');
      const uninstallBtn = document.createElement('button');
      instBtn.textContent = m.installed ? 'Neu installieren' : 'Installieren';
      uninstallBtn.textContent = 'Entfernen';
      uninstallBtn.className='secondary';

      async function callInstallApi(id, uninstall=false){
        const url = uninstall ? '/api/models/uninstall' : '/api/models/install';
        const r = await fetch(url, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({id})});
        if (!r.ok) throw new Error('HTTP '+r.status);
        return await r.json().catch(()=>({ok:true}));
      }

      instBtn.addEventListener('click', async ()=>{
        const id = m.id || m.name;
        instBtn.disabled = true;
        try{
          let ok = false;
          try{ await callInstallApi(id,false); ok = true; }
          catch(e){ ok = true; } // Fallback: lokal markieren
          if (ok){ m.installed = true; saveInstalledLocal(id,true); render(_STATE.items); }
        }catch(e){
          alert('Install fehlgeschlagen: '+e.message);
        }finally{ instBtn.disabled = false; }
      });

      uninstallBtn.addEventListener('click', async ()=>{
        const id = m.id || m.name;
        uninstallBtn.disabled = true;
        try{
          let ok=false;
          try{ await callInstallApi(id,true); ok = true; }
          catch(e){ ok = true; }
          if (ok){ m.installed = false; saveInstalledLocal(id,false); render(_STATE.items); }
        }catch(e){
          alert('Entfernen fehlgeschlagen: '+e.message);
        }finally{ uninstallBtn.disabled = false; }
      });

      actions.appendChild(instBtn);
      actions.appendChild(uninstallBtn);
      card.appendChild(actions);

      document.getElementById('list').appendChild(card);
    }
  }

  const _STATE = { items: [] };

  async function loadAll(){
    let items = await loadFromApi();
    if (!items || !items.length) items = await loadFromStatic();
    items = markInstalledByLocal(items);
    _STATE.items = items;
    render(items);
  }

  document.getElementById('btn-refresh').addEventListener('click', loadAll);
  document.getElementById('search').addEventListener('input', ()=>render(_STATE.items));
  document.getElementById('filter-family').addEventListener('change', ()=>render(_STATE.items));
  document.getElementById('filter-state').addEventListener('change', ()=>render(_STATE.items));

  loadAll().finally(()=>{ window.Andio && Andio.polish && Andio.polish(); });
  </script>
</body>
</html>
